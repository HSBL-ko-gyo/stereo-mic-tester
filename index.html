<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ステレオマイク・テスター</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --panel: #1a1a1a;
      --border: #333;
      --text: #e0e0e0;
      --accent: #00ff88;
      --warn: #ff8800;
      --err: #ff4444;
      --grid: #2a2a2a;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: 'Consolas', 'Monaco', monospace; 
      background: var(--bg); 
      color: var(--text); 
      padding: 20px;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { 
      text-align: center; 
      margin-bottom: 20px; 
      color: var(--accent); 
      font-size: 24px; 
      letter-spacing: 2px;
    }
    .controls { 
      display: flex; 
      gap: 15px; 
      align-items: center; 
      justify-content: center; 
      margin-bottom: 20px; 
      flex-wrap: wrap;
    }
    select, button { 
      padding: 8px 12px; 
      border: 1px solid var(--border); 
      background: var(--panel); 
      color: var(--text); 
      border-radius: 4px;
    }
    button { cursor: pointer; }
    button:hover { background: var(--border); }
    button.active { background: var(--accent); color: var(--bg); }
    .scope-container { 
      display: grid; 
      grid-template-columns: 1fr; 
      gap: 20px; 
      margin-bottom: 20px;
    }
    .scope-panel { 
      background: var(--panel); 
      border: 2px solid var(--border); 
      border-radius: 8px; 
      padding: 15px;
    }
    .scope-header { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      margin-bottom: 10px;
    }
    .scope-title { 
      font-size: 18px; 
      font-weight: bold;
    }
    .scope-title.left { color: #4af; }
    .scope-title.right { color: #f4a; }
    .scope-info { 
      font-size: 12px; 
      color: #888;
    }
    canvas { 
      width: 100%; 
      height: 200px; 
      background: #000; 
      border: 1px solid var(--grid); 
      border-radius: 4px;
    }
    .status { 
      display: flex; 
      justify-content: center; 
      gap: 20px; 
      align-items: center; 
      margin-top: 15px; 
      flex-wrap: wrap;
    }
    .status-item { 
      padding: 5px 10px; 
      background: var(--panel); 
      border: 1px solid var(--border); 
      border-radius: 4px; 
      font-size: 12px;
    }
    .status-item.ok { border-color: var(--accent); color: var(--accent); }
    .status-item.warn { border-color: var(--warn); color: var(--warn); }
    .status-item.err { border-color: var(--err); color: var(--err); }
  </style>
</head>
<body>
  <div class="container">
    <h1>stereo-mic-tester</h1>
    
    <div class="controls">
      <select id="deviceSelect">
        <option>デバイス読み込み中...</option>
      </select>
      <button id="startBtn">START</button>
      <button id="stopBtn">STOP</button>
      <button id="refreshBtn">REFRESH</button>
    </div>

    <div class="scope-container">
      <div class="scope-panel">
        <div class="scope-header">
          <span class="scope-title left">LEFT CHANNEL</span>
          <span class="scope-info" id="infoL">-</span>
        </div>
        <canvas id="canvasL" width="800" height="200"></canvas>
      </div>
      <div class="scope-panel">
        <div class="scope-header">
          <span class="scope-title right">RIGHT CHANNEL</span>
          <span class="scope-info" id="infoR">-</span>
        </div>
        <canvas id="canvasR" width="800" height="200"></canvas>
      </div>
    </div>

    <div class="status">
      <div class="status-item" id="statusDevice">デバイス: -</div>
      <div class="status-item" id="statusSR">サンプルレート: -</div>
      <div class="status-item" id="statusCh">チャンネル: -</div>
      <div class="status-item" id="statusStereo">ステレオ: -</div>
      <div class="status-item" id="statusState">停止中</div>
    </div>
  </div>

  <script>
  (function(){
    const deviceSelect = document.getElementById('deviceSelect');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    
    const canvasL = document.getElementById('canvasL');
    const canvasR = document.getElementById('canvasR');
    const ctxL = canvasL.getContext('2d');
    const ctxR = canvasR.getContext('2d');
    
    const infoL = document.getElementById('infoL');
    const infoR = document.getElementById('infoR');
    const statusDevice = document.getElementById('statusDevice');
    const statusSR = document.getElementById('statusSR');
    const statusCh = document.getElementById('statusCh');
    const statusStereo = document.getElementById('statusStereo');
    const statusState = document.getElementById('statusState');

    let audioCtx = null;
    let stream = null;
    let source = null;
    let splitter = null;
    let analyserL = null, analyserR = null;
    let rafId = null;
    let permissionGranted = false;

    // ロール表示用のバッファ（心電図のような速度）
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 200;
    let rollBufferL = new Float32Array(CANVAS_WIDTH);
    let rollBufferR = new Float32Array(CANVAS_WIDTH);
    let rollIndex = 0;
    let lastUpdateTime = 0;
    const ROLL_SPEED = 50; // ms間隔（心電図のような速度）

    function setStatus(element, text, type = '') {
      element.textContent = text;
      element.className = `status-item ${type}`;
    }

    async function listDevices(){
      try {
        // 許可がまだの場合のみ取得
        if (!permissionGranted) {
          const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          tempStream.getTracks().forEach(t => t.stop());
          permissionGranted = true;
        }
        
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(d => d.kind === 'audioinput');
        
        const currentValue = deviceSelect.value;
        deviceSelect.innerHTML = '';
        
        audioInputs.forEach(device => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label || `マイク ${audioInputs.indexOf(device) + 1}`;
          deviceSelect.appendChild(option);
        });
        
        if (audioInputs.length === 0) {
          const option = document.createElement('option');
          option.textContent = 'オーディオ入力なし';
          deviceSelect.appendChild(option);
        } else if (currentValue) {
          deviceSelect.value = currentValue;
        }
      } catch (e) {
        console.warn('Device enumeration failed:', e);
      }
    }

    function drawRollDisplay(ctx, buffer, color, title) {
      const width = CANVAS_WIDTH;
      const height = CANVAS_HEIGHT;
      
      // 背景をクリア
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);
      
      // グリッド描画
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      
      // 水平線
      for (let i = 0; i <= 4; i++) {
        const y = (height / 4) * i;
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
      }
      
      // 垂直線（時間軸）
      for (let i = 0; i <= 10; i++) {
        const x = (width / 10) * i;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
      }
      ctx.stroke();
      
      // 中央線を強調
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();
      
      // 現在位置の縦線（心電図のカーソルライン）
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(rollIndex, 0);
      ctx.lineTo(rollIndex, height);
      ctx.stroke();
      
      // ロール波形描画
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < width; i++) {
        const sample = buffer[i] || 0;
        const y = (height / 2) - (sample * height / 2 * 3.0); // 0.8 → 3.0に変更で大きく
        
        if (i === 0) {
          ctx.moveTo(i, y);
        } else {
          ctx.lineTo(i, y);
        }
      }
      ctx.stroke();
    }

    function updateRollBuffers(currentTime) {
      if (!analyserL || !analyserR) return;
      
      // 指定間隔でのみ更新（心電図のような速度制御）
      if (currentTime - lastUpdateTime < ROLL_SPEED) return;
      lastUpdateTime = currentTime;
      
      const dataL = new Float32Array(analyserL.fftSize);
      const dataR = new Float32Array(analyserR.fftSize);
      
      analyserL.getFloatTimeDomainData(dataL);
      analyserR.getFloatTimeDomainData(dataR);
      
      // 現在の時点のサンプルを取得（平均値）
      let avgL = 0, avgR = 0;
      const sampleCount = Math.min(64, dataL.length); // 64サンプルの平均
      
      for (let i = 0; i < sampleCount; i++) {
        avgL += dataL[i];
        avgR += dataR[i];
      }
      avgL /= sampleCount;
      avgR /= sampleCount;
      
      // ロールバッファに追加
      rollBufferL[rollIndex] = avgL;
      rollBufferR[rollIndex] = avgR;
      
      // RMSとピーク計算（情報表示用）
      let rmsL = 0, rmsR = 0;
      let peakL = 0, peakR = 0;
      
      for (let i = 0; i < dataL.length; i++) {
        rmsL += dataL[i] * dataL[i];
        peakL = Math.max(peakL, Math.abs(dataL[i]));
      }
      for (let i = 0; i < dataR.length; i++) {
        rmsR += dataR[i] * dataR[i];
        peakR = Math.max(peakR, Math.abs(dataR[i]));
      }
      
      rmsL = Math.sqrt(rmsL / dataL.length);
      rmsR = Math.sqrt(rmsR / dataR.length);
      
      // 情報更新
      infoL.textContent = `RMS: ${(20 * Math.log10(rmsL + 1e-10)).toFixed(1)}dB`;
      infoR.textContent = `RMS: ${(20 * Math.log10(rmsR + 1e-10)).toFixed(1)}dB`;
      
      // ロールインデックスを進める
      rollIndex = (rollIndex + 1) % CANVAS_WIDTH;
      
      // 次の描画位置をクリア（心電図のような先行クリア）
      const clearWidth = 3;
      for (let i = 0; i < clearWidth; i++) {
        const clearIdx = (rollIndex + i) % CANVAS_WIDTH;
        rollBufferL[clearIdx] = 0;
        rollBufferR[clearIdx] = 0;
      }
    }

    function animate(currentTime) {
      if (!audioCtx || audioCtx.state !== 'running') return;
      
      updateRollBuffers(currentTime);
      drawRollDisplay(ctxL, rollBufferL, '#4af', 'LEFT');
      drawRollDisplay(ctxR, rollBufferR, '#f4a', 'RIGHT');
      
      rafId = requestAnimationFrame(animate);
    }

    function cleanup() {
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
      
      if (source) source.disconnect();
      if (splitter) splitter.disconnect();
      if (analyserL) analyserL.disconnect();
      if (analyserR) analyserR.disconnect();
      
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      
      if (audioCtx && audioCtx.state !== 'closed') {
        audioCtx.close();
        audioCtx = null;
      }
      
      analyserL = analyserR = null;
      splitter = null;
      source = null;
      
      // バッファクリア
      rollBufferL.fill(0);
      rollBufferR.fill(0);
      rollIndex = 0;
      
      setStatus(statusState, '停止中', '');
      infoL.textContent = '-';
      infoR.textContent = '-';
      statusStereo.style.display = 'none'; // ステレオ判定を非表示
      
      startBtn.className = '';
      stopBtn.className = '';
    }

    async function start() {
      cleanup();
      
      setStatus(statusState, '初期化中...', '');
      startBtn.className = 'active';
      
      const deviceId = deviceSelect.value;
      const constraints = {
        audio: {
          deviceId: deviceId ? { exact: deviceId } : undefined,
          channelCount: { ideal: 2 },
          sampleRate: { ideal: 48000 },
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        }
      };
      
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
        
        source = audioCtx.createMediaStreamSource(stream);
        splitter = audioCtx.createChannelSplitter(2);
        
        analyserL = audioCtx.createAnalyser();
        analyserR = audioCtx.createAnalyser();
        
        analyserL.fftSize = 2048;
        analyserR.fftSize = 2048;
        analyserL.smoothingTimeConstant = 0;
        analyserR.smoothingTimeConstant = 0;
        
        source.connect(splitter);
        splitter.connect(analyserL, 0);
        splitter.connect(analyserR, 1);
        
        const track = stream.getAudioTracks()[0];
        const settings = track.getSettings();
        
        // デバイス情報をより詳細に取得
        let deviceInfo = track.label || 'Unknown';
        
        // navigator.mediaDevices.enumerateDevices()から詳細情報を取得
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const currentDevice = devices.find(d => d.deviceId === deviceId);
          if (currentDevice && currentDevice.label) {
            deviceInfo = currentDevice.label;
            
            // USB VID:PIDの抽出を試行
            const usbMatch = currentDevice.label.match(/\(([0-9a-fA-F]{4}):([0-9a-fA-F]{4})\)/);
            if (usbMatch) {
              const vid = usbMatch[1].toLowerCase();
              const pid = usbMatch[2].toLowerCase();
              deviceInfo += ` [VID:${vid} PID:${pid}]`;
            }
          }
        } catch (e) {
          console.warn('Failed to get detailed device info:', e);
        }
        
        setStatus(statusDevice, `デバイス: ${deviceInfo}`, 'ok');
        setStatus(statusSR, `サンプルレート: ${audioCtx.sampleRate}Hz`, 'ok');
        setStatus(statusCh, `チャンネル: ${settings.channelCount || 'Unknown'}`, 'ok');
        setStatus(statusState, '動作中', 'ok');
        statusStereo.style.display = 'none'; // ステレオ判定を非表示
        
        lastUpdateTime = 0;
        animate(0);
        
      } catch (error) {
        console.error('Start failed:', error);
        setStatus(statusState, `エラー: ${error.message}`, 'err');
        cleanup();
      }
    }

    // デバイス切り替え対応
    deviceSelect.addEventListener('change', () => {
      if (audioCtx && audioCtx.state === 'running') {
        start(); // 動作中なら新デバイスで再開
      }
    });

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', cleanup);
    refreshBtn.addEventListener('click', listDevices);

    // ステレオ判定を最初から非表示
    statusStereo.style.display = 'none';

    // 初期化
    listDevices();
  })();
  </script>
</body>
</html>
